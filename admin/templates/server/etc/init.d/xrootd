#!/usr/bin/env sh
#
# xrootd/cmsd	This shell script takes care of starting and stopping
#		Qserv xrootd/cmsd instances.
# description: xrootd is the filesystem which allow Qserv master to \
# communicate with Qserv workers.\
# It is composed of two services : xrootd and cmsd
# Note

### BEGIN INIT INFO
# Provides: xrootd cmsd
# Short-Description: start and stop xrootd/cmsd
# Description: XRootD software framework is a fully generic suite for fast, \
#              low latency and scalable data access. It's the communication \
#              middleware used between Qserv master and nodes. \ 
### END INIT INFO

. {{QSERV_RUN_DIR}}/etc/init.d/qserv-functions

XROOTD_DIR={{XROOTD_DIR}}
XROOTD_RUN_DIR={{XROOTD_RUN_DIR}}
XROOTD_CONFIG={{QSERV_RUN_DIR}}/etc/lsp.cf
XROOTD_INSTANCE_NAME="worker"

PID_DIR={{QSERV_PID_DIR}}/${XROOTD_INSTANCE_NAME}
LOG_DIR={{QSERV_LOG_DIR}}

export PATH={{PATH}}
export LD_LIBRARY_PATH={{LD_LIBRARY_PATH}}
export QSW_XRDQUERYPATH="/q"
export QSW_DBSOCK="{{MYSQLD_SOCK}}"
export QSW_MYSQLDUMP=`which mysqldump`
QSW_SCRATCHPATH="{{QSERV_RUN_DIR}}/tmp"
QSW_SCRATCHDB="qservScratch"
export QSW_RESULTPATH="${XROOTD_RUN_DIR}/result"

# method to guess pid file name,
# takes single argument - program name
pid_file_name() {
    local pidfile=${PID_DIR}/$1.pid
    test "${1}{{NODE_TYPE}}" = "cmsdmaster" && pidfile=${PID_DIR}/$1.mangr.pid
    echo $pidfile
}

start_service() {

        local prog

	prog=${1##*/}

	pidfile=$(pid_file_name $prog)
	lockfile={{QSERV_RUN_DIR}}/var/lock/subsys/${prog}
	BINARY=${XROOTD_DIR}/bin/${prog}
	LOGFILE=${LOG_DIR}/${prog}.log
	[ -x ${BINARY} ] || exit 5
	[ -f ${XROOTD_CONFIG} ] || exit 6

	xrootd_cmd="\"${BINARY} -c ${XROOTD_CONFIG} -l ${LOGFILE} -n ${XROOTD_INSTANCE_NAME} &\""
    # xrootd modifies log file path, try to guess it here too, this is not critical,
    # it is only used by start() for diagnostic if start fails.
    # TODO: start should not be using envvar from caller scope, if it needs log file name
    # then we should pass it explicitely
    LOGFILE=${LOG_DIR}/${XROOTD_INSTANCE_NAME}/${prog}.log
	eval start -p ${pidfile} -l ${lockfile} ${prog} ${xrootd_cmd}
}

stop_service() {

        local prog

        prog=${1##*/}

        pidfile=$(pid_file_name $prog)
        lockfile={{QSERV_RUN_DIR}}/var/lock/subsys/${prog}

        eval stop -p $pidfile -l $lockfile $prog
}

start_all() {
        local xrootd_started cmsd_started=0 retval=1
        mkdir -p ${QSW_RESULTPATH} || {
           log_failure_msg "Failed to create ${QSW_RESULTPATH}"
           return 1 
        }
         mkdir -p ${PID_DIR} || {
           log_failure_msg "Failed to create ${PID_DIR}"
           return 1
        }

        start_service "xrootd"
        xrootd_started=$?
        
        {{COMMENT_MONO_NODE}}start_service "cmsd"
        {{COMMENT_MONO_NODE}}cmsd_started=$?
        
        test $xrootd_started -eq 0 -a $cmsd_started -eq 0
}

stop_all() {
        local xrootd_stopped cmsd_stopped=0 retval=1
        
        stop_service "xrootd"
        xrootd_stopped=$?
        
        {{COMMENT_MONO_NODE}}stop_service "cmsd"
        {{COMMENT_MONO_NODE}}cmsd_stopped=$?
        
        test $xrootd_stopped -eq 0 -a $cmsd_stopped -eq 0
}

status_all () {
        local xrootd_status cmsd_status=0 retval=1

        NAME="xrootd"
       	DAEMON=${XROOTD_DIR}/bin/${NAME}
        pidfile=$(pid_file_name $NAME)
       	status_of_proc -p $pidfile "$DAEMON" "$NAME" 
       	xrootd_status=$?

        {{COMMENT_MONO_NODE}}NAME="cmsd"
       	{{COMMENT_MONO_NODE}}DAEMON=${XROOTD_DIR}/bin/${NAME}
        {{COMMENT_MONO_NODE}}pidfile=$(pid_file_name $NAME)
       	{{COMMENT_MONO_NODE}}status_of_proc -p $pidfile "$DAEMON" "$NAME"
       	{{COMMENT_MONO_NODE}}cmsd_status=$?
 
        test $xrootd_status -eq 0 -a $cmsd_status -eq 0
}



# See how we were called.
case "$1" in
  start)
	start_all
	;;
  stop)
	stop_all
	;;
  status)
	status_all
	;;
  restart)
	stop_all
	start_all
	;;
  try-restart|condrestart)
	if status_all > /dev/null; then
	    stop_all
	    start_all
	fi
	;;
  *)
	echo $"Usage: $0 {start|stop|status|restart|try-restart}"
	exit 2
esac
