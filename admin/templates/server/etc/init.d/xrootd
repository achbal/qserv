#!/usr/bin/env sh
#
# xrootd/cmsd	This shell script takes care of starting and stopping
#		Qserv xrootd/cmsd instances.
# description: xrootd is the filesystem which allow Qserv master to \
# communicate with Qserv workers.\
# It is composed of two services : xrootd and cmsd
# Note

### BEGIN INIT INFO
# Provides: xrootd cmsd
# Short-Description: start and stop xrootd/cmsd
# Description: qms is the Qserv Meta Service. It is used by Qserv master
#              in order to get accurate informations about loaded datasets.
#              Note that Qserv service won't start if QMS databse is empty.
### END INIT INFO

. %(QSERV_DIR)s/etc/init.d/qserv-functions

XROOTD_DIR=%(XROOTD_DIR)s
XROOTD_CONFIG=%(QSERV_DIR)s/etc/lsp.cf
XROOTD_INSTANCE_NAME="worker"

PID_DIR=%(QSERV_PID_DIR)s/${XROOTD_INSTANCE_NAME}
LOG_DIR=%(QSERV_LOG_DIR)s


export PATH=%(PATH)s
export LD_LIBRARY_PATH=%(LD_LIBRARY_PATH)s
export QSW_XRDQUERYPATH="/q"
export QSW_DBSOCK="%(MYSQLD_SOCK)s"
export QSW_MYSQLDUMP="mysqldump"
QSW_SCRATCHPATH="%(QSERV_DIR)s/tmp"
QSW_SCRATCHDB="qservScratch"
export QSW_RESULTPATH="%(XROOTD_RUN_DIR)s/result"

start_service() {

        local prog

	prog=${1##*/}

	pidfile=${PID_DIR}/${prog}.pid
	lockfile=%(QSERV_DIR)s/var/lock/subsys/${prog}
	BINARY=${XROOTD_DIR}/bin/${prog}
	LOGFILE=${LOG_DIR}/${prog}.log
	[ -x ${BINARY} ] || exit 5
	[ -f ${XROOTD_CONFIG} ] || exit 6

	xrootd_cmd="\"${BINARY} -c ${XROOTD_CONFIG} -l ${LOGFILE} -n ${XROOTD_INSTANCE_NAME} &\""
	# here pid files will be created twice time : one by xrootd/cmsd and one by start()
	# but it works
	eval start -p ${pidfile} -l ${lockfile} ${prog} ${xrootd_cmd}
	retval=$?
	return $retval
}

stop_service() {

        local prog

        prog=${1##*/}

	pidfile=${PID_DIR}/${prog}.pid
	lockfile=%(QSERV_DIR)s/var/lock/subsys/${prog}

	eval stop -p $pidfile -l $lockfile $prog
	retval=$?
	return $retval
}

start_all() {
        local xrootd_started cmsd_started=0 retval=1
        mkdir -p ${QSW_RESULTPATH} || {
           log_failure_msg "Failed to create ${QSW_RESULTPATH}"
           return 1 
        }
         mkdir -p ${PID_DIR} || {
           log_failure_msg "Failed to create ${PID_DIR}"
           return 1
        }

        start_service "xrootd"
	xrootd_started=$?
        %(COMMENT_MONO_NODE)sstart_service "cmsd"
	%(COMMENT_MONO_NODE)scmsd_started=$?
	[ $xrootd_started -a $cmsd_started ] && retval=0
	return $retval
}

stop_all() {
        local xrootd_stopped cmsd_stopped=0 retval=1
        stop_service "xrootd"
	xrootd_stopped=$?
	%(COMMENT_MONO_NODE)sstop_service "cmsd"
	%(COMMENT_MONO_NODE)scmsd_stopped=$?
	[ $xrootd_stopped -a $cmsd_stopped ] && retval=0
	return $retval
}

status_all () {
        local xrootd_status cmsd_status
	NAME="xrootd"
       	DAEMON=$(which ${NAME})
       	pidfile=${PID_DIR}/${NAME}.pid
       	status_of_proc -p $pidfile "$DAEMON" "$NAME"
	[ ! $xrootd_status ] && return 1

 	#MONO-NODE# NAME="cmsd"
       	#MONO-NODE# DAEMON=$(which ${NAME})
       	#MONO-NODE# pidfile=${PID_DIR}/${NAME}.pid
       	#MONO-NODE# status_of_proc -p $pidfile "$DAEMON" "$NAME"
       	#MONO-NODE# cmsd_status=$?
       	#MONO-NODE# [ ! $cmsd_status ] && return 1
 
       	return 0 
}



# See how we were called.
case "$1" in
  start)
	start_all
	;;
  stop)
	stop_all
	;;
  status)
	status_all
	;;
  restart)
	stop_all
	start_all
	;;
  try-restart|condrestart)
	if status_all > /dev/null; then
	    stop_all
	    start_all
	fi
	;;
  *)
	echo $"Usage: $0 {start|stop|status|restart|try-restart}"
	exit 2
esac
