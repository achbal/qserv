# -*- python -*-
#
# Setup our environment
#
Import('*')
import glob, os, re, sys
import state
from itertools import chain, izip, repeat
from collections import defaultdict
import SCons.Util
import detect # Qserv dep detector


# Describe what your package contains here.
env.Help("""
Qserv core code
""")

# TODO:
#  * Make the configure-check optional.
###
###
extraTgts = {}
extraTgts['dist'] = []
custom = detect.importCustom(env, extraTgts)

detect.checkGeom()
detect.checkTwisted()

# Environment
# Must do all env modifiers here, otherwise SCons complains
# about different environments used to build files in shared components.
if not env.GetOption('clean'):

    detect.addExtern(env, ARGUMENTS.get('extern', None))

    canBuild = detect.checkMySql(env) and detect.setXrootd(env) and detect.checkXrootdLink(env)
    if not canBuild:
        raise StandardError("Can't build")

    env.Append(CPPPATH=[os.getcwd()]) # top level
    state.log.debug("Scons env : " + env.Dump())

    env.Append(CPPFLAGS=["-D_FILE_OFFSET_BITS=64", "-fPIC",
                         "-Wno-unused-local-typedefs"])

# all modules
allModules = """ccontrol css czar global log mysql obsolete
                parser proto proxy qana qdisp qproc query
                rproc sql
                tests util
                wbase wconfig wcontrol wdb wlog wpublish wsched
                xrdc xrdfs xrdoss xrdsvc""".split()

# Dependencies to fix:
# packetiter in util depends on xrdc, util shouldn't depend on anything
# Products
shProducts = { "xrdfs" : {'mods' : """proto xrdfs
                                      mysql sql obsolete util
                                      wbase wconfig wcontrol wdb
                                      wpublish wsched
                                      wlog global""".split(),
                          'libs' : """ssl crypto mysqlclient_r protobuf
                                      boost_regex boost_thread
                                      boost_signals
                                      XrdServer XrdClient
                                      XrdOfs  XrdUtils""".split(),
                          'distDir' : 'lib'},

               "xrdoss" : {'mods' : """wlog mysql obsolete sql util
                                       wbase wconfig
                                       xrdoss wpublish""".split(),
                           'libs' : """boost_regex boost_signals boost_thread
                                       mysqlclient_r ssl crypto""".split(),
                           'distDir' : 'lib'
                           },
               "xrdsvc" : {'mods' : """global mysql proto
                                       sql util wbase
                                       wcontrol wconfig wdb wlog
                                       wpublish wsched
                                       xrdsvc""".split(),
                           'libs' : """boost_regex boost_signals boost_thread
                                       mysqlclient_r protobuf
                                       ssl crypto XrdSsi""".split(),
                           'distDir' : 'lib'
                           },

               "_czarLib" : {'mods' : """css czar ccontrol global
                                         log rproc mysql
                                         parser query
                                         sql util xrdc
                                         obsolete proto
                                         qana qdisp qproc""".split(),
                             'libs' : """ssl crypto antlr
                                      mysqlclient_r protobuf
                                      XrdClient XrdPosix XrdSsi XrdUtils
                                      boost_regex boost_thread boost_system
                                      boost_signals zookeeper_mt""".split(),
                               'SHLIBPREFIX' : '',
                               'distDir' : os.path.join(env['python_relative_prefix'],"lsst","qserv","czar")}
               }

# modules used in shProducts
modList = [m for m in chain(*map(lambda d: d['mods'],
                                shProducts.values()))]
libProducts = dict(izip(modList, repeat(None)))
defaultTgts = dict()

def getSrcs(mName):
    srcs = os.listdir(mName)
    return map(lambda s: os.path.join(mName, s), srcs)


def getTgts(mName):
    scriptPath = os.path.join(mName, "SConscript")
    if env.Glob(scriptPath): # os.access is faulty with VariantDir
        tgts = SConscript(scriptPath,
                          exports={'env': env, 'extraTgts': extraTgts})
        return tgts
    else:
        #print "No targets for %s, using glob" % mName
        # All .cc, except test files.
        files = filter(lambda f: not os.path.basename(str(f)).startswith("test"),
                       env.Glob(os.path.join(mName, "*.cc")))
        files.sort(key=lambda n: n.str_for_display())
        defaultTgts[mName] = files
        return files

objCache = defaultdict(lambda : defaultdict(lambda : None))
def cacheObjs(env, depList, oType):
    """ caches Object() and SharedObject nodes so they can be reused,
        avoiding the scons warning for "two different environments"
    env: scons Environment
    depList: object dependencies
    oType: ".o" or ".os"
    """
    cache = objCache[id(env)]
    result = []
    for d in depList:
        (name,ext) = os.path.splitext(str(d))
        if ext == ".cc":
            oName = name + oType
            if not cache[oName]:
                if oType == ".o": cache[oName] = env.Object(oName, d)
                elif oType == ".os": cache[oName] = env.SharedObject(oName, d)
            result.append(cache[oName])
        else: result.append(d)
    return result

boostChecker = detect.BoostChecker(env)
antlrChecker = detect.AntlrChecker(env)

def findLibs(libList):
    def cheapCheckLib(libName):
        if libName.startswith("boost"):
            return boostChecker.getLibName(libName)
        if libName.startswith("antlr"):
            return antlrChecker.getLibName(libName)
        else: return libName
    return map(cheapCheckLib, libList)

def makeSharedObjectCC(env, ccFile):
    if str(ccFile).endswith(".cc"): return env.SharedObject(ccFile)[0]
    else: return ccFile

def getTests(env, mName):
    state.log.debug("Looking for %s tests" % mName)
    scriptPath = os.path.join(mName, "SConscript.test")
    if env.Glob(scriptPath):
        tgts = SConscript(scriptPath, exports={'env' : env,
                                                'libProducts' : libProducts,
                                                'defaultTgts' : defaultTgts,
                                                'findLibs' : findLibs,
                                                'cacheObjs' : cacheObjs})
        return tgts
    else:
        return None

########################################################################
## Real work now.
########################################################################

# Gather up source files
for mod in allModules:
    libProducts[mod] = getTgts(mod)

# Compute non-custom shared objects
for m in defaultTgts:
    files = defaultTgts[m]
    objs = [makeSharedObjectCC(env, a) for a in set(files)]
    defaultTgts[m] = objs


# Compute shlib targets
for (pkg, opts) in shProducts.items():
    srcs = []
    for m in opts['mods']: # Visit modules and compose union of LIBS
        if m in defaultTgts:
            srcs.extend(defaultTgts[m])
        else:
            prods = libProducts[m]
            srcs.extend(prods)
        pass

    # Eliminate dupes for srcs and libs, and
    # convert .cc to SharedObject to prevent warning
    # (scons: warning: Two different environments)
    srcs = [makeSharedObjectCC(env, a) for a in set(srcs)]
    # Sort to prevent dependency-order rebuilding
    srcs.sort(key=lambda n: n.str_for_display())
    #env.Append(LIBS=libs)
    #extLibFlags = ["-l"+lib for lib in findLibs(opts['libs'])]
    extLibs = [lib for lib in findLibs(opts['libs'])]
    if opts.has_key('SHLIBPREFIX'):
        out = env.SharedLibrary(pkg + ".so", srcs, LIBS=extLibs,
                                SHLIBPREFIX=opts['SHLIBPREFIX'])
    else:
        out = env.SharedLibrary(pkg + ".so", srcs, LIBS=extLibs)
    env.Alias("build", out)
    for f in out:
        extraTgts['dist'].append((opts['distDir'], f))

#Runner wrapper
import runner
env["PYTHONPATH"] = extraTgts["PYTHONPATH"]
target = "qsEnv.sh"
env.Command(target, None, runner.makeRunner)
extraTgts['dist'].append(('bin', env.File(target)))

# Tests

# module tests
state.log.debug("Looking for tests : %s" % map(str, libProducts))
testTgts=[]
for m in libProducts.keys():
    tgts = getTests(env, m)
    if tgts: testTgts.extend(Flatten(tgts))

if testTgts:
    state.log.debug("Test tgts to build: %s" % map(str, testTgts))
env.Alias("build", testTgts)

# unit tests to run
utests = env.get('UNIT_TESTS', [])
if utests:
    # all unit tests run after build target
    env.Requires(utests, "build")
    state.log.debug("Unit tests to run: %s" % map(str, utests))
    # special builder that checks that unit tests were successful
    utestCheck = env.UnitTestCheck('unit-test-check-tag', utests)
    env.Alias('test', utestCheck)

installTgts = (extraTgts['dist'], testTgts)

Return('installTgts')
