# -*- python -*-
#
# Setup our environment
#
# Do not change these
Import('*')
import glob, os, re, sys
from itertools import chain, izip, repeat
import SCons.Util
import detect # Qserv dep detector
##import detect_deps


# Describe what your package contains here.
env.Help("""
Qserv core code
""")

# Detect protobufs
##detect_deps.detectProtobufs()
extraTgts = {}
extraTgts['dist'] = []
canBuild = True
custom = detect.importCustom(env, extraTgts)
geomLib = detect.extractGeometry(custom)
if geomLib:
    extraTgts['dist'].append(('lsst/qserv/master', env.File(geomLib)))
metaFiles = detect.findMeta(env)
for f in metaFiles: extraTgts['dist'].append(('lsst/qserv/meta', f))

# Handle debug
debug = ARGUMENTS.get('debug', 0)
print "debug is", debug
if int(debug):
    print "Debug build requested."
    env.Append(CCFLAGS = '-g')

# Environment
# Must do all env modifiers here, otherwise SCons complains
# about different environments used to build files in shared components.
if not env.GetOption('clean'):
    conf = env.Configure()
    canBuild = canBuild and conf.CheckLibWithHeader("mysqlclient_r",
                                                    "mysql/mysql.h",
                                                    language="C++",
                                                    autoadd=0)
    conf.Finish()
    detect.addExtern(env, ARGUMENTS.get('extern', None))
    if detect.setXrootd(env):
        canBuild = canBuild and detect.checkXrdPosix(env)
    else: canBuild = False
    env.Append(CPPPATH=[os.getcwd()]) # top level
    env.Append(CPPPATH=[env['PROTOC_INC']])

    env.Append(CPPFLAGS=["-D_FILE_OFFSET_BITS=64", "-fPIC"])
    env.Append(CPPPATH=env["PROTOC_INC"])
    env.Append(CPPPATH=["modules"])

if not canBuild:
    raise StandardError("can't build")

# all modules
allModules = """control czar global log merger meta mysql obsolete
                parser proto qana qdisp qproc query tests util
                wbase wconfig wcontrol wdb wsched
                xrdc xrdfs xrdoss""".split()


# Products
shProducts = { "xrdfs" : {'mods' : """proto xrdfs
                                      wbase wconfig wcontrol wdb wsched
                                      log global""".split(),
                          'libs' : """ssl crypto
                                      boost_regex boost_thread
                                      boost_signals
                                      XrdSys XrdServer XrdClient
                                      XrdOfs XrdSfs XrdUtils""".split(),
                          'distDir' : 'lib'},

               "xrdoss" : {'mods' : ["xrdoss"],
                           'libs' : """ssl crypto""".split(),
                           'distDir' : 'lib'
                           },
               "_masterLib" : {'mods' : """czar control parser query
                                           log merger meta mysql util xrdc
                                           obsolete proto
                                           qana qdisp qproc""".split(),
                               'libs' : """ssl crypto antlr
                                      mysqlclient_r protobuf
                                      XrdPosix XrdPosixPreload XrdUtils
                                      boost_regex boost_thread
                                      boost_signals""".split(),
                               'SHLIBPREFIX' : '',
                               'distDir' : 'lsst/qserv/master'}
               }
# modules used in shProducts
modList = [m for m in chain(*map(lambda d: d['mods'],
                                shProducts.values()))]
libProducts = dict(izip(modList, repeat(None)))

# libDepName = "extLibs"
# def getLibDeps(mName):
#     try:
#         libDeps = open(os.path.join(mName, libDepName)).read()
#         return libDeps
#     except IOError, e:
#         #print "Warning, no %s for module %s" % (libDepName, mName)
#         return []

def getSrcs(mName):
#    srcs = os.listdir(os.path.join(mRoot,mName))
#    return map(lambda s: os.path.join(mRoot, mName, s), srcs)
    srcs = os.listdir(mName)
    return map(lambda s: os.path.join(mName, s), srcs)


def getTgts(mName):
    scriptPath = os.path.join(mName, "SConscript")
    if env.Glob(scriptPath): # os.access is faulty with VariantDir
        tgts = SConscript(scriptPath,
                          exports={'env': env, 'extraTgts': extraTgts})
        return tgts
    else:
        #print "No targets for %s, using glob" % mName
        # All .cc, except test files.
        return filter(lambda f: not str(f).startswith("test"),
                      env.Glob(os.path.join(mName, "*.cc")))

boostChecker = detect.BoostChecker(env)
def findLibs(libList):
    def cheapCheckLib(libName):
        if libName.startswith("boost"):
            return boostChecker.getLibName(libName)
        else: return libName
    return map(cheapCheckLib, libList)
hasMysql = detect.checkMySql2(env)

def makeSharedObjectCC(env, ccFile):
    if str(ccFile).endswith(".cc"): return env.SharedObject(ccFile)
    else: return ccFile

def getTests(mName):
    scriptPath = os.path.join(mName, "SConscript.test")
    if env.Glob(scriptPath):
        tests = SConscript(scriptPath, exports={'env': env,
                                                'libProducts': libProducts})
        return tgts
    else:
        return None
########################################################################
## Real work now.
########################################################################

# Gather up source files
#for mod in libProducts:
#    objs = getTgts(mod)
#    libProducts[mod] = objs
for mod in allModules:
    libProducts[mod] = getTgts(mod)


# Compute shlib targets
for (pkg, opts) in shProducts.items():
    srcs = []
    for m in opts['mods']: # Visit modules and compose union of LIBS
        prods = libProducts[m]
        srcs.extend(prods)
        pass

    # Eliminate dupes for srcs and libs, and
    # convert .cc to SharedObject to prevent warning
    # (scons: warning: Two different environments)
    srcs = [makeSharedObjectCC(env, a) for a in set(srcs)]

    #env.Append(LIBS=libs)
    #extLibFlags = ["-l"+lib for lib in findLibs(opts['libs'])]
    extLibs = [lib for lib in findLibs(opts['libs'])]
    if opts.has_key('SHLIBPREFIX'):
        out = env.SharedLibrary(pkg + ".so", srcs, LIBS=extLibs,
                                SHLIBPREFIX=opts['SHLIBPREFIX'])
    else:
        out = env.SharedLibrary(pkg + ".so", srcs, LIBS=extLibs)
    extraTgts['dist'].append((opts['distDir'], out))

#Runner wrapper

import runner
print extraTgts["PYTHONPATH"]
env["PYTHONPATH"] = extraTgts["PYTHONPATH"]
f = runner.WrapperScript(env, "qsEnv.sh")
extraTgts['dist'].append(('bin', f))

# Install targets
distDir = 'dist'
for (path, f) in extraTgts['dist']:
    print "REally installing:", f
    env.Install(os.path.join(distDir, path), f)


# Tests

# module tests
for m in libProducts.keys():
    tgts = getTests(m)
    if tgts: print tgts
if False:
    testCc = env.Glob(m+'/test*cc')
    for t in testCc:
        (path,f) = os.path.split(str(t))
        (pName, ext) = os.path.splitext(f)
        dep = env.Glob(os.path.join(path, pName + ".depend"))
        depList = []
        if dep:
            v = env.Variables(dep[0])
            print v
            for line in open(dep[0]).readlines():
                print "["+line+"]"
                #depList.append(env.Glob(os.path.join(path,
        # FIXME
        #p = env.Program(f+"bin", [t] + libProducts[m] + )
#
# Build/install things
#

#####################################################################
# Variant support
#    VariantDir(bldDir, 'src')
#    SConscript("src/SConscript.lib", variant_dir=bldDir,
#               exports={'env' : expEnv, 'detect_deps' : detect_deps})

# for d in Split("proto src tests doc"):
#     if os.path.isdir(d):
#         try:
#             SConscript(os.path.join(d, "SConscript"),
#                        exports={'env' : env})
#         except Exception, e:
#             print >> sys.stderr, "%s: %s" % (os.path.join(d, "SConscript"), e)
