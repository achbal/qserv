#!/usr/bin/env python

# LSST Data Management System
# Copyright 2013 LSST Corporation.
# 
# This product includes software developed by the
# LSST Project (http://www.lsst.org/).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the LSST License Statement and 
# the GNU General Public License along with this program.  If not, 
# see <http://www.lsstcorp.org/LegalNotices/>.

"""
qserv client program used by all users that talk to qserv. A thin shell that parses
commands, reads all input data in the form of config files into arrays, and calls
corresponding function.

Known todos:
 - many commands still need to be implemented
 - need to separate dangerous admin commands like DROP EVERYTHING

"""

import os
import re
import readline
import signal
import sys
import ConfigParser

from qserv_admin_impl import QservAdminImpl

class CommandParser(object):
    """
    Parses commands and calls appropriate function from qserv_admin_impl.
    """
    def __init__(self):
        self._funcMap = {
            'CREATE':  self._parseCreate,
            'DROP':    self._parseDrop,
            'HELP':    self._printHelp,
            'RELEASE': self._parseRelease,
            'SHOW':    self._parseShow
            }
        self._impl = QservAdminImpl()
        self._supportedCommands = """
  Supported commands:
    CREATE DATABASE <dbName> <configFile>;
    CREATE DATABASE <dbName> LIKE <dbName2>;
    DROP DATABASE <dbName>;
    DROP EVERYTHING;
    SHOW DATABASES;
    SHOW EVERYTHING;
    QUIT;
    EXIT;
    ...more coming soon
"""

    ################################################################################
    #### main parser
    ################################################################################
    def parse(self, cmd):
        """Main parser, dispatches to subparsers based on first word. Returns true
           when exit was requested. Throws exceptions on errors."""
        cmd = cmd.strip()
        # ignore empty commands, these can be generated by typing ;;
        if len(cmd) == 0: return 
        tokens = cmd.split()
        t = tokens[0].upper()
        if t in self._funcMap:
            self._funcMap[t](tokens[1:])
            return False
        elif t == 'EXIT' or t == 'QUIT':
            return True
        else:
            raise Exception("Bad cmd (not supported yet): '%s'" % cmd)

    ################################################################################
    #### subparser CREATE
    ################################################################################
    def _parseCreate(self, tokens):
        """Subparser, handles all CREATE requests."""
        t = tokens[0].upper()
        if t == 'DATABASE':
            self._parseCreateDatabase(tokens[1:])
        elif t == 'TABLE':
            self._parseCreateTable(tokens[1:])
        else:
            raise Exception('CREATE '+t+' not supported') 

    ################################################################################
    #### subparser "CREATE DATABASE"
    ################################################################################
    def _parseCreateDatabase(self, tokens):
        """Subparser, handles all CREATE DATABASE requests."""
        l = len(tokens)
        if l == 2:
            dbName = tokens[0]
            configFile = tokens[1]
            options = self._fetchOptionsFromConfigFile(configFile)
            options = self._processDbOptions(options)
            self._impl.createDb(dbName, options)
        elif l == 3:
            if tokens[1].upper() != 'LIKE':
                raise Exception("Bad cmd (expected 'LIKE'): "+cmd)
            dbName = tokens[0]
            dbName2 = tokens[2]
            self._impl.createDbLike(dbName, dbName2)
        else:
            raise Exception('Bad cmd (wrong token count:'+str(l)+")")

    ################################################################################
    #### subparser: CREATE TABLE
    ################################################################################
    def _parseCreateTable(self, tokens):
        """Subparser, handles all CREATE TABLE requests."""
        print 'CREATE TABLE not implemented.'

    ################################################################################
    #### _subparser: DROP
    ################################################################################
    def _parseDrop(self, tokens):
        """Subparser, handles all DROP requests."""
        t = tokens[0].upper()
        l = len(tokens)
        if t == 'DATABASE':
            if l != 2:
                raise Exception('Bad cmd (wrong token count)')
            self._impl.dropDb(tokens[1])
        elif t == 'TABLE':
            print "drop table not implemented" 
        elif t == 'EVERYTHING':
            self._impl.dropEverything()
        else:
            raise Exception('DROP '+t+' not supported') 

    ###############################################################################
    #### _printHelp
    ################################################################################
    def _printHelp(self, tokens):
        """Prints available commands."""
        print self._supportedCommands

    ################################################################################
    #### subparser: RELEASE
    ################################################################################
    def _parseRelease(self, tokens):
        """Subparser, handles all RELEASE requests."""
        print 'RELEASE not implemented.'

    ################################################################################
    #### subparser: SHOW
    ################################################################################
    def _parseShow(self, tokens):
        """Subparser, handles all SHOW requests."""
        t = tokens[0].upper()
        if t == 'DATABASES':
            self._impl.showDatabases()
        elif t == 'EVERYTHING':
            self._impl.showEverything()
        else:
            raise Exception('SHOW '+t+' not supported') 

    ################################################################################
    #### _createDb
    ################################################################################
    def _createDb(self, dbName, configFile):
        """Create database through config file."""
        print "Creating db '%s' using config '%s'" % (dbName, configFile)
        options = self._fetchOptionsFromConfigFile(configFile)
        print "options are:", options
        self._impl.createDb(dbName, options)

    ################################################################################
    #### _processing options for createDb and createTable
    ################################################################################
    def _fetchOptionsFromConfigFile(self, fName):
        """It reads the config file for createDb or createTable command, and returns
           key-value pair dictionary (flat, e.g., sections are ignored.)"""
        if not os.access(fName, os.R_OK):
            raise Exception("Specified config file '%s' not found." % fName)
        config = ConfigParser.ConfigParser()
        config.optionxform = str # case sensitive
        config.read(fName)
        xx = {}
        for section in config.sections():
            for option in config.options(section):
                xx[option] = config.get(section, option)
        return xx

    ################################################################################
    def _processDbOptions(self, opts):
        """Validates options used by createDb, adds default values for missing
           parameters."""
        if not opts.has_key("clusteredIndex"):
            print("param 'clusteredIndex' not found, will use default: ''")
            opts["clusteredIndex"] = ''
        if not opts.has_key("partitioning"):
            print("param 'partitioning' not found, will use default: off")
            opts["partitioning"] = "off"
        if not opts.has_key("objectIdIndex"):
            print("param 'objectIdIndex' not found, will use default: ''")
            opts["objectIdIndex"] = ''
        # these are required options for createDb
        _crDbOpts = { 
            "db_info": ("level", 
                        "partitioning", 
                        "partitioningStrategy")}
        _crDbPSOpts = {
            "sphBox":("nStripes", 
                      "nSubStripes", 
                      "overlap")}
        # validate the options
        self._validateKVOptions(opts, _crDbOpts, _crDbPSOpts, "db_info")
        return opts

    ################################################################################
    def _validateKVOptions(self, x, xxOpts, psOpts, whichInfo):
        if not x.has_key("partitioning"):
            raise Exception ("Can't find required param 'partitioning'")

        partOff = x["partitioning"] == "off" 
        for (theName, theOpts) in xxOpts.items():
            for o in theOpts:
                # skip optional parameters
                if o == "partitioning":
                    continue
                # if partitioning is "off", partitioningStrategy does not 
                # need to be specified 
                if not (o == "partitiongStrategy" and partOff):
                    continue
                if not x.has_key(o):
                    raise Exception("Can't find required param '%s'" % o)
        if partOff:
            return
        if x["partitioning"] != "on":
            raise Exception ("Unrecognized value for param 'partitioning' "
                             "(%s), supported on/off" % x["partitioning"])

        if not x.has_key("partitioningStrategy"):
            raise Exception("partitioningStrategy option is required if "
                            "partitioning is on")

        psFound = False
        for (psName, theOpts) in psOpts.items():
            if x["partitioningStrategy"] == psName:
                psFound = True
                # check if all required options are specified
                for o in theOpts:
                    if not x.has_key(o):
                        raise Exception ("Can't find param '%s' required for "
                                         "partitioning strategy '%s'" % (o, psName))
                # check if there are any unrecognized options
                for o in x:
                    if not ((o in xxOpts[whichInfo]) or (o in theOpts)):
                        # skip non required, these are not in xxOpts/theOpts
                        if whichInfo=="db_info" and o=="clusteredIndex":
                            continue
                        if whichInfo=="db_info" and o=="objectIdIndex":
                            continue
                        if whichInfo=="table_info" and o=="partitioningStrategy":
                            continue
                        raise Exception("Unrecognized param '%s' found" % o)
        if not psFound:
            raise Exception("Unrecongnized partitioning strategy '%s', "
                             "supported strategies: 'sphBox'" % \
                                x["partitioningStrategy"])
    ####################################################################################
#### receiveCommands
####################################################################################
def receiveCommands():
    """Receives user commands. End of command is determined by ';'. Multiple 
       commands per line are allowed. Multi-line commands are allowed. 
       To terminate: CTRL-D, or "exit;" or quit;"."""
    cp = CommandParser()
    line = ''
    sql = ''
    try:
        done = False
        while not done:
            line = raw_input("qserv > ")
            sql += line.strip()+' '
            while re.search(';', sql):
                pos = sql.index(';')
                done = cp.parse(sql[:pos])
                sql = sql[pos+1:]
    except EOFError:
        print ""
        return

####################################################################################
#### auto-completion
####################################################################################
class VolcabCompleter:
    """Set auto-completion for commonly used words."""
    def __init__(self, volcab):
        self.volcab = volcab

    def complete(self, text, state):
        results = [x+' ' for x in self.volcab 
                   if x.startswith(text.upper())] + [None]
        return results[state]

readline.parse_and_bind("tab: complete")
words = ['CONFIG',
         'CREATE',
         'DATABASE',
         'DATABASES',
         'DROP',
         'INTO',
         'LIKE',
         'LOAD',
         'RELEASE',
         'SHOW',
         'TABLE']
completer = VolcabCompleter(words)
readline.set_completer(completer.complete)

####################################################################################
#### catching Ctrl-C
####################################################################################
def signal_handler(signal, frame):
    print ""
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

####################################################################################
#### main
####################################################################################
def main():
    receiveCommands()

if __name__ == "__main__":
    main()
