#!/usr/bin/env python

# LSST Data Management System
# Copyright 2013 LSST Corporation.
# 
# This product includes software developed by the
# LSST Project (http://www.lsst.org/).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the LSST License Statement and 
# the GNU General Public License along with this program.  If not, 
# see <http://www.lsstcorp.org/LegalNotices/>.

"""
qserv client program. A thin shell that parses commands, reads all input data
in the form of config files into arrays, and calls corresponding function.
"""

import re
import readline

SUCCESS = 0

class CommandParser(object):
    """
    Parses commands and calls appropriate function.
    Supported commands:
    CREATE DATABASE <dbName> <configFile>
    CREATE DATABASE <dbName> LIKE <dbName2>
    coming soon: DROP, RELEASE, SHOW and more...
    """
    def __init__(self):
        self._funcMap = {
            'CREATE':  self._parseCreate,
            'DROP':    self._parseDrop,
            'RELEASE': self._parseRelease,
            'SHOW':    self._parseShow
            }

    # ---------------------------------------------------------------------------
    def parse(self, cmd):
        """Main parser, dispatches to subparsers based on first word."""
        cmd = cmd.strip()
        # ignore empty commands, these can be generated by typing ;;
        if len(cmd) == 0: return 
        print "Parsing: '%s'" % cmd
        tokens = cmd.split()
        t = tokens[0].upper()
        if t in self._funcMap:
            return self._funcMap[t](tokens[1:])
        else:
            raise Exception('Bad cmd (not supported yet): '+cmd)

    # ---------------------------------------------------------------------------
    def _parseCreate(self, tokens):
        """Subparser, handles all CREATE requests."""
        t = tokens[0].upper()
        if t == 'DATABASE':
            return self._parseCreateDatabase(tokens[1:])
        elif t == 'TABLE':
            return self._parseCreateTable(tokens[1:])
        else:
            raise Exception('CREATE '+t+' not supported') 

    # --------------------------------------------------------------------------
    def _parseCreateDatabase(self, tokens):
        """Subparser, handles all CREATE DATABASE requests."""
        l = len(tokens)
        if l == 2:
            dbName = tokens[0]
            configFile = tokens[1]
            return self._createDb(dbName, configFile)
        elif l == 3:
            if tokens[1].upper() != 'LIKE':
                raise Exception('Bad cmd (expected LIKE): '+cmd)
            dbName = tokens[0]
            dbName2 = tokens[2]
            return self._createDbLike(dbName, dbName2)
        else:
            raise Exception('Bad cmd (wrong token count:'+str(l)+")")

    # --------------------------------------------------------------------------
    def _parseCreateTable(self, tokens):
        """Subparser, handles all CREATE TABLE requests."""
        print 'CREATE TABLE not implemented.'

    # --------------------------------------------------------------------------
    def _parseDrop(self, tokens):
        """Subparser, handles all DROP requests."""
        print 'DROP not implemented.'

    # --------------------------------------------------------------------------
    def _parseRelease(self, tokens):
        """Subparser, handles all RELEASE requests."""
        print 'RELEASE not implemented.'

    # --------------------------------------------------------------------------
    def _parseShow(self, tokens):
        """Subparser, handles all SHOW requests."""
        print 'SHOW not implemented.'

    # --------------------------------------------------------------------------
    def _createDb(self, dbName, configFile):
        """Create database through config file."""
        print "Creating db '%s' using config '%s'" % (dbName, configFile)
        print "The guts are not quite implemented yet, come back soon..."
        return SUCCESS

    # --------------------------------------------------------------------------
    def _createDbLike(self, dbName, dbName2):
        """Create database like some other existing database."""
        print "Creating db '%s' like '%s'" % (dbName, dbName2)
        print "The guts are not quite implemented yet, come back soon..."
        return SUCCESS

# ------------------------------------------------------------------------------
def receiveCommands():
    """Receives user commands. End of command is determined by ';'. Multiple 
       commands per line are allowed. Multi-line commands are allowed. 
       Terminates when command "exit" is received."""
    cp = CommandParser()
    line = ''
    sql = ''
    while not re.match('exit', line):
        line = raw_input("qserv > ")
        sql += line.strip()+' '
        while re.search(';', sql):
            pos = sql.index(';')
            cp.parse(sql[:pos])
            sql = sql[pos+1:]

# ------------------------------------------------------------------------------
class VolcabCompleter:
    """Set auto-completion for commonly used words."""
    def __init__(self, volcab):
        self.volcab = volcab

    def complete(self, text, state):
        results = [x+' ' for x in self.volcab 
                   if x.startswith(text.upper())] + [None]
        return results[state]

readline.parse_and_bind("tab: complete")
words = ['CONFIG',
         'CREATE',
         'DATABASE',
         'DROP',
         'INTO',
         'LIKE',
         'LOAD',
         'RELEASE',
         'SHOW',
         'TABLE']
completer = VolcabCompleter(words)
readline.set_completer(completer.complete)

# ------------------------------------------------------------------------------
def main():
    receiveCommands()

if __name__ == "__main__":
    main()
