#!/usr/bin/env python

# LSST Data Management System
# Copyright 2013 LSST Corporation.
# 
# This product includes software developed by the
# LSST Project (http://www.lsst.org/).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the LSST License Statement and 
# the GNU General Public License along with this program.  If not, 
# see <http://www.lsstcorp.org/LegalNotices/>.

"""
qserv client program.
"""

import re
import readline

SUCCESS = 0

# ------------------------------------------------------------------------------
# Parses commands and calls appropriate function.
# Supported commands:
#   CREATE DATABASE <dbName> <configFile>
#   CREATE DATABASE <dbName> LIKE <dbName2>
#   coming soon: DROP, RELEASE, SHOW and more...
#   
class CommandParser(object):
    def __init__(self):
        None
    # --------------------------------------------------------------------------
    # main parser, dispatches to subparsers based on first word
    def parse(self, cmd):
        cmd = cmd.strip()
        # ignore empty commands, these can be generated by typing ;;
        if len(cmd) == 0: return 
        print "Parsing: '%s'" % cmd
        tokens = cmd.split()
        t = tokens[0].upper()
        if t == 'CREATE':
            return self._parseCreate(tokens[1:])
        elif t == 'DROP':
            return self._parseDrop(tokens[1:])
        elif t == 'RELEASE':
            return self._parseRelease(tokens[1:])
        elif t == 'SHOW':
            return self._parseShow(tokens[1:])
        else:
            raise Exception('Bad cmd (not supported yet): '+cmd)
    # --------------------------------------------------------------------------
    # subparser, handles all CREATE requests
    def _parseCreate(self, tokens):
        t = tokens[0].upper()
        if t == 'DATABASE':
            return self._parseCreateDatabase(tokens[1:])
        elif t == 'TABLE':
            return self._parseCreateTable(tokens[1:])
        else:
            raise Exception('CREATE '+t+' not supported') 

    # --------------------------------------------------------------------------
    # subparser, handles all CREATE DATABASE requests
    def _parseCreateDatabase(self, tokens):
        l = len(tokens)
        if l == 2:
            dbName = tokens[0]
            configFile = tokens[1]
            return self._createDb(dbName, configFile)
        elif l == 3:
            if tokens[1].upper() != 'LIKE':
                raise Exception('Bad cmd (expected LIKE): '+cmd)
            dbName = tokens[0]
            dbName2 = tokens[2]
            return self._createDbLike(dbName, dbName2)
        else:
            raise Exception('Bad cmd (wrong token count:'+str(l)+")")

    # --------------------------------------------------------------------------
    # subparser, handles all CREATE TABLE requests
    def _parseCreateTable(self, tokens):
        raise Exception('CREATE TABLE not implemented.')

    # --------------------------------------------------------------------------
    # subparser, handles all DROP requests
    def _parseDrop(self, tokens):
        raise Exception('DROP not implemented.')

    # --------------------------------------------------------------------------
    # subparser, handles all RELEASE requests
    def _parseRelease(self, tokens):
        raise Exception('RELEASE not implemented.')

    # --------------------------------------------------------------------------
    # subparser, handles all SHOW requests
    def _parseShow(self, tokens):
        raise Exception('SHOW not implemented.')

    # --------------------------------------------------------------------------
    # create database through config file
    def _createDb(self, dbName, configFile):
        print "Creating db '%s' using config '%s'" % (dbName, configFile)
        print "The guts are not quite implemented yet, come back soon..."
        return SUCCESS

    # --------------------------------------------------------------------------
    # create database like some other existing database
    def _createDbLike(self, dbName, dbName2):
        print "Creating db '%s' like '%s'" % (dbName, dbName2)
        print "The guts are not quite implemented yet, come back soon..."
        return SUCCESS

# ------------------------------------------------------------------------------
# Receives user commands. End of command is determined by ';'. Multiple commands
# per line are allowed. Multi-line commands are allowed.  Terminates when
# command "exit" is received.
def receiveCommands():
    cp = CommandParser()
    line = ''
    sql = ''
    while not re.match('exit', line):
        line = raw_input("qserv > ")
        sql += line.strip()+' '
        while re.search(';', sql):
            pos = sql.index(';')
            cp.parse(sql[:pos])
            sql = sql[pos+1:]

# ------------------------------------------------------------------------------
# set auto-completion for commonly used words
class VolcabCompleter:
    def __init__(self, volcab):
        self.volcab = volcab

    def complete(self, text, state):
        results = [x+' ' for x in self.volcab 
                   if x.startswith(text.upper())] + [None]
        return results[state]

readline.parse_and_bind("tab: complete")
words = ['CONFIG',
         'CREATE',
         'DATABASE',
         'DROP',
         'INTO',
         'LIKE',
         'LOAD',
         'RELEASE',
         'SHOW',
         'TABLE']
completer = VolcabCompleter(words)
readline.set_completer(completer.complete)

# ------------------------------------------------------------------------------
# main
def main():
    receiveCommands()

if __name__ == "__main__":
    main()
