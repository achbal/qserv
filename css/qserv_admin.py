#!/usr/bin/env python

# LSST Data Management System
# Copyright 2013 LSST Corporation.
# 
# This product includes software developed by the
# LSST Project (http://www.lsst.org/).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the LSST License Statement and 
# the GNU General Public License along with this program.  If not, 
# see <http://www.lsstcorp.org/LegalNotices/>.

"""
qserv client program used by all users that talk to qserv. A thin shell that
parses commands, reads all input data in the form of config files into arrays,
and calls corresponding function.
"""

import os
import re
import readline
import ConfigParser

from qserv_admin_impl import QservAdminImpl

SUCCESS = 0

class CommandParser(object):
    """
    Parses commands and calls appropriate function.
    Supported commands:
    CREATE DATABASE <dbName> <configFile>
    CREATE DATABASE <dbName> LIKE <dbName2>
    SHOW DATABASES
    DROP DATABASE <dbName>
    ...more coming soon
    """
    def __init__(self):
        self._funcMap = {
            'CREATE':  self._parseCreate,
            'DROP':    self._parseDrop,
            'RELEASE': self._parseRelease,
            'SHOW':    self._parseShow
            }
        self._impl = QservAdminImpl()

    # ---------------------------------------------------------------------------
    def parse(self, cmd):
        """Main parser, dispatches to subparsers based on first word."""
        cmd = cmd.strip()
        # ignore empty commands, these can be generated by typing ;;
        if len(cmd) == 0: return 
        print "Parsing: '%s'" % cmd
        tokens = cmd.split()
        t = tokens[0].upper()
        if t in self._funcMap:
            return self._funcMap[t](tokens[1:])
        else:
            raise Exception('Bad cmd (not supported yet): '+cmd)

    # ---------------------------------------------------------------------------
    def _parseCreate(self, tokens):
        """Subparser, handles all CREATE requests."""
        t = tokens[0].upper()
        if t == 'DATABASE':
            return self._parseCreateDatabase(tokens[1:])
        elif t == 'TABLE':
            return self._parseCreateTable(tokens[1:])
        else:
            raise Exception('CREATE '+t+' not supported') 

    # --------------------------------------------------------------------------
    def _parseCreateDatabase(self, tokens):
        """Subparser, handles all CREATE DATABASE requests."""
        l = len(tokens)
        if l == 2:
            dbName = tokens[0]
            configFile = tokens[1]
            options = self._fetchOptionsFromConfigFile(configFile)
            print "options are:", options
            return self._impl.createDb(dbName, options)
        elif l == 3:
            if tokens[1].upper() != 'LIKE':
                raise Exception("Bad cmd (expected 'LIKE'): "+cmd)
            dbName = tokens[0]
            dbName2 = tokens[2]
            return self._impl.createDbLike(dbName, dbName2)
        else:
            raise Exception('Bad cmd (wrong token count:'+str(l)+")")

    # --------------------------------------------------------------------------
    def _parseCreateTable(self, tokens):
        """Subparser, handles all CREATE TABLE requests."""
        print 'CREATE TABLE not implemented.'

    # --------------------------------------------------------------------------
    def _parseDrop(self, tokens):
        """Subparser, handles all DROP requests."""
        t = tokens[0].upper()
        l = len(tokens)
        if t == 'DATABASE':
            if l != 2:
                raise Exception('Bad cmd (wrong token count)')
            return self._impl.dropDb(tokens[1])
        elif t == 'TABLE':
            print "drop table not implemented" 
        else:
            raise Exception('CREATE '+t+' not supported') 

    # --------------------------------------------------------------------------
    def _parseRelease(self, tokens):
        """Subparser, handles all RELEASE requests."""
        print 'RELEASE not implemented.'

    # --------------------------------------------------------------------------
    def _parseShow(self, tokens):
        """Subparser, handles all SHOW requests."""
        t = tokens[0].upper()
        if t == 'DATABASES':
            return self._impl.showDatabases()
        raise Exception('SHOW '+t+' not supported') 

    # --------------------------------------------------------------------------
    def _createDb(self, dbName, configFile):
        """Create database through config file."""
        print "Creating db '%s' using config '%s'" % (dbName, configFile)
        options = self._fetchOptionsFromConfigFile(configFile)
        print "options are:", options
        return self._impl.createDb(dbName, options)

    def _fetchOptionsFromConfigFile(self, fName):
        """It reads the config file for createDb or createTable command,
           and returns key-value pair dictionary (flat, e.g., sections
           are ignored.)"""
        if not os.access(fName, os.R_OK):
            raise Exception("Specified config file '%s' not found." % fName)
        config = ConfigParser.ConfigParser()
        config.optionxform = str # case sensitive
        config.read(fName)
        xx = {}
        for section in config.sections():
            for option in config.options(section):
                xx[option] = config.get(section, option)
        return xx

# ------------------------------------------------------------------------------
def receiveCommands():
    """Receives user commands. End of command is determined by ';'. Multiple 
       commands per line are allowed. Multi-line commands are allowed. 
       Terminates when command "exit" is received."""
    cp = CommandParser()
    line = ''
    sql = ''
    while not re.match('exit', line):
        line = raw_input("qserv > ")
        sql += line.strip()+' '
        while re.search(';', sql):
            pos = sql.index(';')
            cp.parse(sql[:pos])
            sql = sql[pos+1:]

# ------------------------------------------------------------------------------
class VolcabCompleter:
    """Set auto-completion for commonly used words."""
    def __init__(self, volcab):
        self.volcab = volcab

    def complete(self, text, state):
        results = [x+' ' for x in self.volcab 
                   if x.startswith(text.upper())] + [None]
        return results[state]

readline.parse_and_bind("tab: complete")
words = ['CONFIG',
         'CREATE',
         'DATABASE',
         'DATABASES',
         'DROP',
         'INTO',
         'LIKE',
         'LOAD',
         'RELEASE',
         'SHOW',
         'TABLE']
completer = VolcabCompleter(words)
readline.set_completer(completer.complete)

# ------------------------------------------------------------------------------
def main():
    receiveCommands()

if __name__ == "__main__":
    main()
