/* 
 * LSST Data Management System
 * Copyright 2008, 2009, 2010 LSST Corporation.
 * 
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the LSST License Statement and 
 * the GNU General Public License along with this program.  If not, 
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */

// SelectParser is the top-level manager for everything attached to
// parsing the top-level SQL query. Given an input query and a
// configuration, computes a query info structure, name ref list, and
// a "query plan".  


// Standard
#include <functional>
#include <cstdio>
#include <strings.h>

// Boost
#include <boost/make_shared.hpp>
#include <boost/bind.hpp>

// Local (placed in src/)
#include "SqlSQL2Parser.hpp" 
#include "SqlSQL2Lexer.hpp"
#include "SqlSQL2TokenTypes.hpp"
#if 0
#include "lsst/qserv/master/Callback.h"
#include "lsst/qserv/master/SqlParseRunner.h"
#include "lsst/qserv/master/Substitution.h"
#include "lsst/qserv/master/stringUtil.h"
#include "lsst/qserv/master/TableRefChecker.h"
#include "lsst/qserv/master/TableNamer.h"
#include "lsst/qserv/master/TableRemapper.h"
#include "lsst/qserv/master/SpatialUdfHandler.h"
#endif
#include "lsst/qserv/master/SelectStmt.h"

#include "lsst/qserv/master/SelectParser.h"
#include "lsst/qserv/master/parseTreeUtil.h"

#include <antlr/CommonAST.hpp>
// namespace modifiers
namespace qMaster = lsst::qserv::master;

////////////////////////////////////////////////////////////////////////
// AntlrParser -- Antlr parsing complex
////////////////////////////////////////////////////////////////////////
class qMaster::AntlrParser {
public:
    AntlrParser(std::string const& q) 
        : statement(q), 
          stream(q, std::stringstream::in | std::stringstream::out),
          lexer(stream),
          parser(lexer)
        {}
    void run() {
        parser.initializeASTFactory(factory);
        parser.setASTFactory(&factory);
        parser.sql_stmt();
        explore();
    }
    void explore();
    std::string statement;
    std::stringstream stream;
    ASTFactory factory;
    SqlSQL2Lexer lexer;
    SqlSQL2Parser parser;
};
void 
qMaster::AntlrParser::explore() {
    RefAST a = parser.getAST();
//    std::cout << "printing walktree \n";
//    printIndented(a);

}

////////////////////////////////////////////////////////////////////////
// class SelectParser
////////////////////////////////////////////////////////////////////////

// Static factory function
qMaster::SelectParser::Ptr 
qMaster::SelectParser::newInstance(std::string const& statement, 
                                   std::string const& delimiter,
                                   StringMap const& config) {
    return boost::shared_ptr<SelectParser>(new SelectParser(statement, 
                                                            delimiter,
                                                            config));

}

// Construtor
qMaster::SelectParser::SelectParser(std::string const& statement, 
                                    std::string const& delimiter,
                                    StringMap const& config) 
    :_statement(statement) {

}

void 
qMaster::SelectParser::setup() {
    _selectStmt.reset(new SelectStmt());
    _aParser.reset(new AntlrParser(_statement));
    _selectStmt->addHooks(_aParser->parser);
    _aParser->run();
    _selectStmt->diagnose();
    _import();
}

/// Using the AST generated by the parser (which should have some
/// branching and imaginary nodes, retrieve the contextual information
/// and put it into our data structures.
void qMaster::SelectParser::_import() {
    using qMaster::walkSiblingString;
    RefAST root = _aParser->parser.getAST();
    RefAST selectListRoot = root->getNextSibling(); 
    assert(selectListRoot.get());
    if(selectListRoot->getType() == SqlSQL2TokenTypes::ASTERISK) {
        std::cout << "Select* detected. " << std::endl;
        return; // FIXME
    }
    RefAST selectList = selectListRoot->getFirstChild();
    assert(selectList.get()); 
//    assert(selectList->getType() == ANTLR_SELECT_LIST);
    std::cout << "selectlisttype is " 
              << SqlSQL2TokenTypes::SELECT_LIST << std::endl;
    std::cout << "select list is: " 
              << "(" << selectListRoot->getType() << ") "
              << walkSiblingString(selectList) 
              << std::endl;
    // FIXME
}

