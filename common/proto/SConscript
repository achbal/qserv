# -*- python -*-
Import('env')
import os
import export_deps

# Construct proto env (add protoc Builder)
pEnv = env.Clone(tools=['default', 'protoc'], PROTOC=os.environ["PROTOC"])
pFiles = pEnv.Protoc(
    [],
    "worker.proto",
    PROTOCPROTOPATH=['.',],
    PROTOCPYTHONOUTDIR=".",
    PROTOCOUTDIR = ".",
    #PROTOCOUTDIR = 'build', # defaults to same directory as .proto
    # PROTOCCPPOUTFLAGS = "dllexport_decl=PROTOCONFIG_EXPORT:", too 
)

pyFiles = filter(lambda s: str(s).endswith(".py"), pFiles)
if pFiles:
    pf = env.Install("../python", pyFiles[0])
    ## This feels icky, but it's the simplest solution for now.
    masterPython = "../../master/python/lsst/qserv/master"
    env.Alias("master", env.Install(masterPython, pyFiles[0]))
else:
    print "WARNING: No python generated for protocol."

sources = ["worker.pb.cc", "TaskMsgDigest.cc"]
pEnv.Append(CPPPATH=[os.environ["PROTOC_INC"], ".."],
            LIBPATH=os.environ["PROTOC_LIB"],
            CPPFLAGS=['-fPIC'])
lib = pEnv.Library("qserv_proto", sources)

# Export proto lib + dependency 
deps = {'LIBPATH' : [os.path.abspath(os.environ["PROTOC_LIB"])],
        'LIBS' : ['protobuf','ssl', 'crypto']}
tup = export_deps.installWithDeps(env, lib, "qserv_proto", "../lib", deps)
env.Append(built_libs=[tup[0]])

# Export proto header + dependency 
deps = {'CPPPATH' : [os.path.abspath(os.environ["PROTOC_INC"])]}
tup = export_deps.installWithDeps(env, "worker.pb.h", "worker.pb.h",
                                  "../include/lsst/qserv", deps)
# Export msg digest header + dependency 
env.Install("../include/lsst/qserv", "TaskMsgDigest.h")



